{"ast":null,"code":"import { locationKey } from \"./EditorStateHandler\";\n/**\n * Converts editor state into DES file format for use with NetHack\n */\n\nclass StateCompiler {\n  constructor() {\n    this.getMapBoundary = state => {\n      let minx = Number.MAX_VALUE;\n      let maxx = 0;\n      let miny = Number.MAX_VALUE;\n      let maxy = 0;\n\n      for (const key in state.tiles) {\n        const tile = state.tiles[key];\n        if (tile.x > maxx) maxx = tile.x;\n        if (tile.x < minx) minx = tile.x;\n        if (tile.y > maxy) maxy = tile.y;\n        if (tile.y < miny) miny = tile.y;\n      }\n\n      return {\n        minx,\n        miny,\n        maxx,\n        maxy\n      };\n    };\n\n    this.generateMap = (state, mapBounds) => {\n      console.log(\"State\", state);\n      const mapGridRows = [];\n\n      for (let y = 0; y <= mapBounds.maxy - mapBounds.miny; y++) {\n        const mapRow = [];\n\n        for (let x = 0; x <= mapBounds.maxx - mapBounds.minx; x++) {\n          const tileKey = locationKey(x + mapBounds.minx, y + mapBounds.miny);\n\n          if (tileKey in state.tiles) {\n            const tileData = state.tiles[tileKey]; // If we have a player character, then put a floor. The \"player\" is dealth with by adding a BRANCH\n\n            if (tileData.category !== \"Player\" && tileData.category !== \"Staircase\" && tileData.category !== \"Monster\") {\n              mapRow.push(tileData.glyphChar);\n            } else {\n              mapRow.push(\".\");\n            }\n          } else {\n            mapRow.push(\" \");\n          }\n        }\n\n        mapGridRows.push(mapRow.join(\"\"));\n      }\n\n      const mapGridAscii = mapGridRows.reverse().join(\"\\n\");\n      const mapString = `\nMAP\n${mapGridAscii}\nENDMAP\n\n`;\n      return mapString;\n    };\n\n    this.generateHeader = state => {\n      const header = `\nMAZE: \"${state.levelName}\", ' '\nFLAGS:premapped\nGEOMETRY:center,center\n`;\n      return header;\n    };\n\n    this.generateFooter = (state, mapBounds) => {\n      for (const key in state.tiles) {\n        const tileData = state.tiles[key];\n      }\n\n      const startLocation = {\n        x: -1,\n        y: -1\n      };\n      const stairLocation = {\n        x: -1,\n        y: -1\n      };\n      const monsterLocations = [];\n\n      for (const key in state.tiles) {\n        const tileData = state.tiles[key];\n\n        if (tileData.category === \"Staircase\") {\n          stairLocation.x = tileData.x - mapBounds.minx;\n          stairLocation.y = mapBounds.maxy - tileData.y;\n        } else if (tileData.category === \"Player\") {\n          startLocation.x = tileData.x - mapBounds.minx;\n          startLocation.y = mapBounds.maxy - tileData.y;\n        } else if (tileData.category === \"Monster\") {\n          monsterLocations.push({\n            x: tileData.x - mapBounds.minx,\n            y: mapBounds.maxy - tileData.y\n          });\n        }\n      }\n\n      let footer = \"\";\n\n      if (stairLocation.x >= 0) {\n        footer += `STAIR:(${stairLocation.x}, ${stairLocation.y}),down\\n`;\n      }\n\n      if (startLocation.x >= 0) {\n        footer += `BRANCH: (${startLocation.x},${startLocation.y},${startLocation.x},${startLocation.y}),(${startLocation.x + 1},${startLocation.y + 1},${startLocation.x + 1},${startLocation.y + 1})\\n`;\n      }\n\n      if (monsterLocations.length > 0) {\n        monsterLocations.map(location => {\n          footer += `MONSTER: random, random, (${location.x},${location.y})\\n`;\n        });\n      }\n\n      return footer;\n    };\n\n    this.compile = state => {\n      const mapBounds = this.getMapBoundary(state);\n      const header = this.generateHeader(state);\n      const map = this.generateMap(state, mapBounds);\n      const footer = this.generateFooter(state, mapBounds);\n      return header + map + footer;\n    };\n  }\n\n}\n\nexport default StateCompiler;","map":{"version":3,"sources":["/Users/xiaochentian/Desktop/43008_RL_Reinforcement_Learning/Assignment3/43008_RL_MiniHack/src/StateCompiler.js"],"names":["locationKey","StateCompiler","getMapBoundary","state","minx","Number","MAX_VALUE","maxx","miny","maxy","key","tiles","tile","x","y","generateMap","mapBounds","console","log","mapGridRows","mapRow","tileKey","tileData","category","push","glyphChar","join","mapGridAscii","reverse","mapString","generateHeader","header","levelName","generateFooter","startLocation","stairLocation","monsterLocations","footer","length","map","location","compile"],"mappings":"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","sourcesContent":["import { locationKey } from \"./EditorStateHandler\";\n\n/**\n * Converts editor state into DES file format for use with NetHack\n */\nclass StateCompiler {\n  getMapBoundary = (state) => {\n    let minx = Number.MAX_VALUE;\n    let maxx = 0;\n    let miny = Number.MAX_VALUE;\n    let maxy = 0;\n\n    for (const key in state.tiles) {\n      const tile = state.tiles[key];\n      if (tile.x > maxx) maxx = tile.x;\n      if (tile.x < minx) minx = tile.x;\n      if (tile.y > maxy) maxy = tile.y;\n      if (tile.y < miny) miny = tile.y;\n    }\n\n    return {\n      minx,\n      miny,\n      maxx,\n      maxy,\n    };\n  };\n\n  generateMap = (state, mapBounds) => {\n    console.log(\"State\", state);\n\n    const mapGridRows = [];\n\n    for (let y = 0; y <= mapBounds.maxy - mapBounds.miny; y++) {\n      const mapRow = [];\n      for (let x = 0; x <= mapBounds.maxx - mapBounds.minx; x++) {\n        const tileKey = locationKey(x + mapBounds.minx, y + mapBounds.miny);\n        if (tileKey in state.tiles) {\n          const tileData = state.tiles[tileKey];\n\n          // If we have a player character, then put a floor. The \"player\" is dealth with by adding a BRANCH\n          if (\n            tileData.category !== \"Player\" &&\n            tileData.category !== \"Staircase\" &&\n            tileData.category !== \"Monster\"\n          ) {\n            mapRow.push(tileData.glyphChar);\n          } else {\n            mapRow.push(\".\");\n          }\n        } else {\n          mapRow.push(\" \");\n        }\n      }\n      mapGridRows.push(mapRow.join(\"\"));\n    }\n\n    const mapGridAscii = mapGridRows.reverse().join(\"\\n\");\n\n    const mapString = `\nMAP\n${mapGridAscii}\nENDMAP\n\n`;\n    return mapString;\n  };\n\n  generateHeader = (state) => {\n    const header = `\nMAZE: \"${state.levelName}\", ' '\nFLAGS:premapped\nGEOMETRY:center,center\n`;\n\n    return header;\n  };\n\n  generateFooter = (state, mapBounds) => {\n    for (const key in state.tiles) {\n      const tileData = state.tiles[key];\n    }\n\n    const startLocation = { x: -1, y: -1 };\n    const stairLocation = { x: -1, y: -1 };\n    const monsterLocations = [];\n    for (const key in state.tiles) {\n      const tileData = state.tiles[key];\n      if (tileData.category === \"Staircase\") {\n        stairLocation.x = tileData.x - mapBounds.minx;\n        stairLocation.y = mapBounds.maxy - tileData.y;\n      } else if (tileData.category === \"Player\") {\n        startLocation.x = tileData.x - mapBounds.minx;\n        startLocation.y = mapBounds.maxy - tileData.y;\n      } else if (tileData.category === \"Monster\") {\n        monsterLocations.push({\n          x: tileData.x - mapBounds.minx,\n          y: mapBounds.maxy - tileData.y,\n        });\n      }\n    }\n\n    let footer = \"\";\n\n    if (stairLocation.x >= 0) {\n      footer += `STAIR:(${stairLocation.x}, ${stairLocation.y}),down\\n`;\n    }\n\n    if (startLocation.x >= 0) {\n      footer += `BRANCH: (${startLocation.x},${startLocation.y},${\n        startLocation.x\n      },${startLocation.y}),(${startLocation.x + 1},${startLocation.y + 1},${\n        startLocation.x + 1\n      },${startLocation.y + 1})\\n`;\n    }\n\n    if (monsterLocations.length > 0) {\n      monsterLocations.map(location => {\n        footer += `MONSTER: random, random, (${location.x},${location.y})\\n`;\n      });\n        \n    }\n    return footer;\n  };\n\n  compile = (state) => {\n    const mapBounds = this.getMapBoundary(state);\n    const header = this.generateHeader(state);\n    const map = this.generateMap(state, mapBounds);\n    const footer = this.generateFooter(state, mapBounds);\n    return header + map + footer;\n  };\n}\n\nexport default StateCompiler;\n"]},"metadata":{},"sourceType":"module"}