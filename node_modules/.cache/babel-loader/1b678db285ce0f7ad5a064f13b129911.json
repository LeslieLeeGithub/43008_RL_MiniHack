{"ast":null,"code":"var _jsxFileName = \"/Users/xiaochentian/Desktop/43008_RL_Reinforcement_Learning/Assignment3/43008_RL_MiniHack/src/EnvDesigner.js\";\nimport PropTypes from \"prop-types\";\nimport React, { Component } from \"react\";\nimport { Col, Row } from \"react-bootstrap\";\nimport * as THREE from \"three\";\nimport EditorStateHandler, { locationKey } from \"./EditorStateHandler\";\nimport StateCompiler from \"./StateCompiler\";\nimport { createTileIdKey } from \"./TileSet\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\n\nclass EnvDesigner extends Component {\n  constructor(props) {\n    var _this;\n\n    super(props);\n    _this = this;\n\n    this.createHighlightSquare = function () {\n      let color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0xaaaaaa;\n      const material = new THREE.LineBasicMaterial({\n        color\n      });\n      return new THREE.Line(_this.geometries.square, material);\n    };\n\n    this.createTileSprite = (tileData, key) => {\n      let tileId;\n      console.log(\"creating tile sprite for\", tileData);\n      console.log(\"Category:\", tileData.category);\n\n      if (tileData.category === \"Walls\") {\n        const upKey = locationKey(tileData.x, tileData.y + 1);\n        const downKey = locationKey(tileData.x, tileData.y - 1);\n        const leftKey = locationKey(tileData.x + 1, tileData.y);\n        const rightKey = locationKey(tileData.x - 1, tileData.y);\n        const upWall = this.isTileCategory(\"Walls\", upKey);\n        const rightWall = this.isTileCategory(\"Walls\", rightKey);\n        const downWall = this.isTileCategory(\"Walls\", downKey);\n        const leftWall = this.isTileCategory(\"Walls\", leftKey);\n        let tileOffset = 0;\n        console.log(\"Up\", upWall);\n        console.log(\"Right\", rightWall);\n        console.log(\"Down\", downWall);\n        console.log(\"Left\", leftWall);\n\n        if ((rightWall || leftWall) && !upWall && !downWall) {\n          tileOffset = 1;\n        } else if (!rightWall && !leftWall && (upWall || downWall)) {\n          tileOffset = 0;\n        } else if (!downWall) {\n          tileOffset = 4;\n        } else {\n          tileOffset = 3;\n        }\n\n        tileId = createTileIdKey(\"Walls\", tileOffset);\n      } else {\n        tileId = tileData.tileId;\n      }\n\n      const material = this.tilesetMaterial[tileId].clone();\n      return new THREE.Sprite(material);\n    };\n\n    this.recompileState = () => {\n      const state = this.editorStateHandler.getState();\n      const desString = this.stateCompiler.compile(state);\n      this.props.onCompile(desString);\n    };\n\n    this.resizeCanvas = (gridWidth, gridHeight) => {\n      const camera = new THREE.OrthographicCamera(0, gridWidth, gridHeight, 0, -100, 100);\n\n      if (this.mount === null || this.mount.parentNode === null) {\n        return;\n      }\n\n      let canvasWidth = this.mount.parentNode.offsetWidth;\n      let canvasHeight = gridHeight * canvasWidth / gridWidth;\n\n      if (canvasHeight > this.maxEditorHeight) {\n        canvasHeight = this.maxEditorHeight;\n        canvasWidth = gridWidth * canvasHeight / gridHeight;\n      }\n\n      this.renderer.setSize(canvasWidth, canvasHeight);\n      this.setState(state => {\n        return { ...state,\n          camera\n        };\n      });\n    };\n\n    this.onCanvasResize = e => {\n      this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n    };\n\n    const points = [];\n    points.push(new THREE.Vector3(-0.5, -0.5, 1));\n    points.push(new THREE.Vector3(-0.5, 0.5, 1));\n    points.push(new THREE.Vector3(0.5, 0.5, 1));\n    points.push(new THREE.Vector3(0.5, -0.5, 1));\n    points.push(new THREE.Vector3(-0.5, -0.5, 1));\n    this.geometries = {};\n    this.components = {};\n    this.tiles = new Map();\n    this.maxEditorHeight = 700;\n    this.geometries.square = new THREE.BufferGeometry().setFromPoints(points);\n    this.state = {\n      cursorGridPosition: new THREE.Vector2(),\n      camera: new THREE.OrthographicCamera(0, this.props.gridWidth, this.props.gridHeight, 0, -100, 100),\n      gridHeight: this.props.gridHeight,\n      gridWidth: this.props.gridWidth\n    };\n    this.currentSelectedTile = {\n      tileId: false\n    };\n    this.editorStateHandler = this.props.editorStateHandler;\n    this.stateCompiler = new StateCompiler();\n    this.renderer = new THREE.WebGLRenderer();\n  }\n\n  isTileCategory(category, key) {\n    return key in this.tiles && this.tiles[key].category === category;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.gridWidth != this.props.gridWidth || prevProps.gridHeight != this.props.gridHeight) {\n      this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n    }\n  }\n\n  componentDidMount() {\n    this.mount.appendChild(this.renderer.domElement);\n    this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n    this.mouseX = 0;\n    this.mouseY = 0;\n    const scene = new THREE.Scene();\n    const textureLoader = new THREE.TextureLoader();\n    this.recompileState(); // Preload Tilesets\n\n    this.tilesetMaterial = {};\n    const allTiles = this.props.tileset.getTiles();\n\n    for (const categoryName in allTiles) {\n      const category = allTiles[categoryName];\n\n      for (let t = 0; t < category.length; t++) {\n        const tileData = category[t];\n        const texture = textureLoader.load(\"tilesets/nethack/\" + tileData.image);\n        const material = new THREE.SpriteMaterial({\n          map: texture\n        });\n        this.tilesetMaterial[tileData.tileId] = material;\n      }\n    }\n\n    this.components.highlightSquare = this.createHighlightSquare(0xaaffaa);\n    scene.add(this.components.highlightSquare);\n    this.highlightSprite = null;\n\n    const removeTile = key => {\n      scene.remove(this.tiles[key].sprite);\n      delete this.tiles[key];\n    };\n\n    const paintTile = (key, tileData) => {\n      const sprite = this.createTileSprite(tileData, tileData);\n      scene.add(sprite);\n      sprite.position.x = tileData.x + 0.5;\n      sprite.position.y = tileData.y + 0.5;\n      tileData.sprite = sprite;\n      this.tiles[key] = tileData;\n    };\n\n    const repaintTile = key => {\n      const tileData = this.tiles[key];\n      scene.remove(tileData.sprite);\n      paintTile(key, tileData);\n    };\n\n    const repaintSurroundingWalls = (x, y) => {\n      const upKey = locationKey(x, y + 1);\n      const downKey = locationKey(x, y - 1);\n      const leftKey = locationKey(x + 1, y);\n      const rightKey = locationKey(x - 1, y);\n\n      if (this.isTileCategory(\"Walls\", upKey)) {\n        repaintTile(upKey);\n      }\n\n      if (this.isTileCategory(\"Walls\", downKey)) {\n        repaintTile(downKey);\n      }\n\n      if (this.isTileCategory(\"Walls\", leftKey)) {\n        repaintTile(leftKey);\n      }\n\n      if (this.isTileCategory(\"Walls\", rightKey)) {\n        repaintTile(rightKey);\n      }\n    };\n\n    const animate = () => {\n      requestAnimationFrame(animate);\n      const editorRect = this.renderer.domElement.getBoundingClientRect();\n      const editorX = editorRect.left;\n      const editorY = editorRect.bottom;\n      const editorWidth = editorRect.right - editorRect.left;\n      const editorHeight = editorRect.bottom - editorRect.top;\n      const cursorGridPosition = new THREE.Vector2(Math.floor((this.mouseX - editorX) / (editorWidth / this.props.gridWidth)), Math.floor((editorY - this.mouseY) / (editorHeight / this.props.gridHeight)));\n      this.components.highlightSquare.position.x = cursorGridPosition.x + 0.5;\n      this.components.highlightSquare.position.y = cursorGridPosition.y + 0.5; // Tile selection and overlay\n\n      if (this.currentSelectedTile.tileId !== this.props.selectedTile.tileId && this.props.selectedTile.tileId) {\n        this.currentSelectedTile = this.props.selectedTile;\n\n        if (this.highlightSprite) {\n          this.components.highlightSquare.remove(this.highlightSprite);\n        }\n\n        this.highlightSprite = this.createTileSprite(this.props.selectedTile, cursorGridPosition);\n        this.highlightSprite.material.opacity = 0.5;\n        this.highlightSprite.material.transparent = true;\n        this.components.highlightSquare.add(this.highlightSprite);\n      } // Actually render the created map\n\n\n      const editorState = this.editorStateHandler.getState(); // loop through the tiles and render them\n\n      for (const [key, tileData] of Object.entries(editorState.tiles)) {\n        let addSprite = false;\n\n        if (!(key in this.tiles)) {\n          addSprite = true;\n        } else if (this.tiles[key].tileId !== tileData.tileId) {\n          scene.remove(this.tiles[key].sprite);\n          addSprite = true;\n        }\n\n        if (addSprite) {\n          paintTile(key, tileData);\n          repaintSurroundingWalls(tileData.x, tileData.y);\n        }\n      } // Loop through scene and remove tiles we don't need anymore\n\n\n      for (const [key, tileData] of Object.entries(this.tiles)) {\n        if (!(key in editorState.tiles)) {\n          removeTile(key);\n          repaintSurroundingWalls(tileData.x, tileData.y);\n        }\n      }\n\n      this.setState(state => {\n        return { ...state,\n          cursorGridPosition\n        };\n      });\n      this.renderer.render(scene, this.state.camera);\n    };\n\n    animate(this);\n    this.mount.addEventListener(\"mousemove\", e => {\n      this.mouseX = e.clientX;\n      this.mouseY = e.clientY;\n    });\n    this.mount.addEventListener(\"contextmenu\", e => {\n      e.preventDefault();\n    });\n    this.mount.addEventListener(\"mouseup\", e => {\n      const gridX = this.state.cursorGridPosition.x;\n      const gridY = this.state.cursorGridPosition.y;\n      e.preventDefault();\n      console.log(e.button);\n      console.log(\"Adding current tile:\", this.currentSelectedTile);\n\n      if (this.currentSelectedTile.tileId) {\n        if (e.button === 0) {\n          this.editorStateHandler.addTile(gridX, gridY, this.currentSelectedTile);\n          this.recompileState();\n        }\n      }\n\n      if (e.button === 2) {\n        this.editorStateHandler.removeTile(gridX, gridY);\n        this.recompileState();\n      }\n    });\n    window.addEventListener('resize', this.onCanvasResize, false);\n  }\n\n  render() {\n    return /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"ep-ide-editor\",\n        ref: ref => this.mount = ref\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 9\n      }, this)\n    }, void 0, false);\n  }\n\n}\n\nEnvDesigner.propTypes = {\n  tileset: PropTypes.any,\n  selectedTile: PropTypes.any,\n  onCompile: PropTypes.any,\n  gridHeight: PropTypes.any,\n  gridWidth: PropTypes.any\n};\nexport default EnvDesigner;","map":{"version":3,"sources":["/Users/xiaochentian/Desktop/43008_RL_Reinforcement_Learning/Assignment3/43008_RL_MiniHack/src/EnvDesigner.js"],"names":["PropTypes","React","Component","Col","Row","THREE","EditorStateHandler","locationKey","StateCompiler","createTileIdKey","EnvDesigner","constructor","props","createHighlightSquare","color","material","LineBasicMaterial","Line","geometries","square","createTileSprite","tileData","key","tileId","console","log","category","upKey","x","y","downKey","leftKey","rightKey","upWall","isTileCategory","rightWall","downWall","leftWall","tileOffset","tilesetMaterial","clone","Sprite","recompileState","state","editorStateHandler","getState","desString","stateCompiler","compile","onCompile","resizeCanvas","gridWidth","gridHeight","camera","OrthographicCamera","mount","parentNode","canvasWidth","offsetWidth","canvasHeight","maxEditorHeight","renderer","setSize","setState","onCanvasResize","e","points","push","Vector3","components","tiles","Map","BufferGeometry","setFromPoints","cursorGridPosition","Vector2","currentSelectedTile","WebGLRenderer","componentDidUpdate","prevProps","componentDidMount","appendChild","domElement","mouseX","mouseY","scene","Scene","textureLoader","TextureLoader","allTiles","tileset","getTiles","categoryName","t","length","texture","load","image","SpriteMaterial","map","highlightSquare","add","highlightSprite","removeTile","remove","sprite","paintTile","position","repaintTile","repaintSurroundingWalls","animate","requestAnimationFrame","editorRect","getBoundingClientRect","editorX","left","editorY","bottom","editorWidth","right","editorHeight","top","Math","floor","selectedTile","opacity","transparent","editorState","Object","entries","addSprite","render","addEventListener","clientX","clientY","preventDefault","gridX","gridY","button","addTile","window","ref","propTypes","any"],"mappings":"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","sourcesContent":["import PropTypes from \"prop-types\";\nimport React, { Component } from \"react\";\nimport { Col, Row } from \"react-bootstrap\";\nimport * as THREE from \"three\";\nimport EditorStateHandler, { locationKey } from \"./EditorStateHandler\";\nimport StateCompiler from \"./StateCompiler\";\nimport { createTileIdKey } from \"./TileSet\";\n\nclass EnvDesigner extends Component {\n  constructor(props) {\n    super(props);\n    const points = [];\n    points.push(new THREE.Vector3(-0.5, -0.5, 1));\n    points.push(new THREE.Vector3(-0.5, 0.5, 1));\n    points.push(new THREE.Vector3(0.5, 0.5, 1));\n    points.push(new THREE.Vector3(0.5, -0.5, 1));\n    points.push(new THREE.Vector3(-0.5, -0.5, 1));\n\n    this.geometries = {};\n    this.components = {};\n    this.tiles = new Map();\n\n    this.maxEditorHeight = 700;\n\n    \n    this.geometries.square = new THREE.BufferGeometry().setFromPoints(points);\n\n    this.state = {\n      cursorGridPosition: new THREE.Vector2(),\n      camera: new THREE.OrthographicCamera(\n        0,\n        this.props.gridWidth,\n        this.props.gridHeight,\n        0,\n        -100,\n        100\n      ),\n      gridHeight: this.props.gridHeight,\n      gridWidth: this.props.gridWidth,\n    };\n\n    this.currentSelectedTile = {\n      tileId: false,\n    };\n\n    this.editorStateHandler = this.props.editorStateHandler;\n    this.stateCompiler = new StateCompiler();\n    this.renderer = new THREE.WebGLRenderer();\n  }\n\n  createHighlightSquare = (color = 0xaaaaaa) => {\n    const material = new THREE.LineBasicMaterial({ color });\n    return new THREE.Line(this.geometries.square, material);\n  };\n\n  isTileCategory(category, key) {\n    return key in this.tiles && this.tiles[key].category === category;\n  }\n\n  createTileSprite = (tileData, key) => {\n    let tileId;\n    console.log(\"creating tile sprite for\", tileData);\n    console.log(\"Category:\", tileData.category);\n    if (tileData.category === \"Walls\") {\n      const upKey = locationKey(tileData.x, tileData.y + 1);\n      const downKey = locationKey(tileData.x, tileData.y - 1);\n      const leftKey = locationKey(tileData.x + 1, tileData.y);\n      const rightKey = locationKey(tileData.x - 1, tileData.y);\n      const upWall = this.isTileCategory(\"Walls\", upKey);\n      const rightWall = this.isTileCategory(\"Walls\", rightKey);\n      const downWall = this.isTileCategory(\"Walls\", downKey);\n      const leftWall = this.isTileCategory(\"Walls\", leftKey);\n\n      let tileOffset = 0;\n\n      console.log(\"Up\", upWall);\n      console.log(\"Right\", rightWall);\n      console.log(\"Down\", downWall);\n      console.log(\"Left\", leftWall);\n      if ((rightWall || leftWall) && !upWall && !downWall) {\n        tileOffset = 1;\n      } else if (!rightWall && !leftWall && (upWall || downWall)) {\n        tileOffset = 0;\n      } else if (!downWall) {\n        tileOffset = 4;\n      } else {\n        tileOffset = 3;\n      }\n\n      tileId = createTileIdKey(\"Walls\", tileOffset);\n    } else {\n      tileId = tileData.tileId;\n    }\n\n    const material = this.tilesetMaterial[tileId].clone();\n    return new THREE.Sprite(material);\n  };\n\n  recompileState = () => {\n    const state = this.editorStateHandler.getState();\n    const desString = this.stateCompiler.compile(state);\n    this.props.onCompile(desString);\n  };\n\n  resizeCanvas = (gridWidth, gridHeight) => {\n\n    const camera = new THREE.OrthographicCamera(\n      0,\n      gridWidth,\n      gridHeight,\n      0,\n      -100,\n      100\n    );\n\n    if(this.mount === null || this.mount.parentNode === null ) {\n      return;\n    }\n\n    let canvasWidth = this.mount.parentNode.offsetWidth;\n    let canvasHeight = (gridHeight*canvasWidth)/gridWidth;\n\n    if(canvasHeight > this.maxEditorHeight) {\n      canvasHeight = this.maxEditorHeight;\n      canvasWidth = (gridWidth*canvasHeight)/gridHeight;\n    }\n\n    this.renderer.setSize(canvasWidth, canvasHeight);\n\n    this.setState((state) => {\n      return {\n        ...state,\n        camera,\n      };\n    });\n  }\n\n  onCanvasResize = (e) => {\n    this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n  }\n\n  componentDidUpdate(prevProps) {\n    if(prevProps.gridWidth != this.props.gridWidth || prevProps.gridHeight != this.props.gridHeight) {\n      this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n    }\n  }\n\n  componentDidMount() {\n\n    this.mount.appendChild(this.renderer.domElement);\n\n    this.resizeCanvas(this.props.gridWidth, this.props.gridHeight);\n\n    this.mouseX = 0;\n    this.mouseY = 0;\n\n    const scene = new THREE.Scene();\n\n    const textureLoader = new THREE.TextureLoader();\n\n    this.recompileState();\n\n    // Preload Tilesets\n    this.tilesetMaterial = {};\n    const allTiles = this.props.tileset.getTiles();\n    for (const categoryName in allTiles) {\n      const category = allTiles[categoryName];\n      for (let t = 0; t < category.length; t++) {\n        const tileData = category[t];\n        const texture = textureLoader.load(\n          \"tilesets/nethack/\" + tileData.image\n        );\n        const material = new THREE.SpriteMaterial({ map: texture });\n        this.tilesetMaterial[tileData.tileId] = material;\n      }\n    }\n\n    this.components.highlightSquare = this.createHighlightSquare(0xaaffaa);\n    scene.add(this.components.highlightSquare);\n    this.highlightSprite = null;\n\n    const removeTile = (key) => {\n      scene.remove(this.tiles[key].sprite);\n      delete this.tiles[key];\n    };\n\n    const paintTile = (key, tileData) => {\n      const sprite = this.createTileSprite(tileData, tileData);\n      scene.add(sprite);\n      sprite.position.x = tileData.x + 0.5;\n      sprite.position.y = tileData.y + 0.5;\n      tileData.sprite = sprite;\n      this.tiles[key] = tileData;\n    };\n\n    const repaintTile = (key) => {\n      const tileData = this.tiles[key];\n      scene.remove(tileData.sprite);\n      paintTile(key, tileData);\n    };\n\n    const repaintSurroundingWalls = (x, y) => {\n      const upKey = locationKey(x, y + 1);\n      const downKey = locationKey(x, y - 1);\n      const leftKey = locationKey(x + 1, y);\n      const rightKey = locationKey(x - 1, y);\n      if (this.isTileCategory(\"Walls\", upKey)) {\n        repaintTile(upKey);\n      }\n      if (this.isTileCategory(\"Walls\", downKey)) {\n        repaintTile(downKey);\n      }\n      if (this.isTileCategory(\"Walls\", leftKey)) {\n        repaintTile(leftKey);\n      }\n      if (this.isTileCategory(\"Walls\", rightKey)) {\n        repaintTile(rightKey);\n      }\n    };\n\n    const animate = () => {\n      requestAnimationFrame(animate);\n\n      const editorRect = this.renderer.domElement.getBoundingClientRect();\n\n      const editorX = editorRect.left;\n      const editorY = editorRect.bottom;\n\n      const editorWidth = editorRect.right - editorRect.left;\n      const editorHeight = editorRect.bottom - editorRect.top;\n\n      const cursorGridPosition = new THREE.Vector2(\n        Math.floor((this.mouseX - editorX) / (editorWidth / this.props.gridWidth)),\n        Math.floor((editorY - this.mouseY) / (editorHeight / this.props.gridHeight))\n      );\n\n      this.components.highlightSquare.position.x = cursorGridPosition.x + 0.5;\n      this.components.highlightSquare.position.y = cursorGridPosition.y + 0.5;\n\n      // Tile selection and overlay\n      if (\n        this.currentSelectedTile.tileId !== this.props.selectedTile.tileId &&\n        this.props.selectedTile.tileId\n      ) {\n        this.currentSelectedTile = this.props.selectedTile;\n        if (this.highlightSprite) {\n          this.components.highlightSquare.remove(this.highlightSprite);\n        }\n        this.highlightSprite = this.createTileSprite(\n          this.props.selectedTile,\n          cursorGridPosition\n        );\n        this.highlightSprite.material.opacity = 0.5;\n        this.highlightSprite.material.transparent = true;\n        this.components.highlightSquare.add(this.highlightSprite);\n      }\n\n      // Actually render the created map\n      const editorState = this.editorStateHandler.getState();\n\n      // loop through the tiles and render them\n      for (const [key, tileData] of Object.entries(editorState.tiles)) {\n        let addSprite = false;\n        if (!(key in this.tiles)) {\n          addSprite = true;\n        } else if (this.tiles[key].tileId !== tileData.tileId) {\n          scene.remove(this.tiles[key].sprite);\n          addSprite = true;\n        }\n\n        if (addSprite) {\n          paintTile(key, tileData);\n          repaintSurroundingWalls(tileData.x, tileData.y);\n        }\n      }\n\n      // Loop through scene and remove tiles we don't need anymore\n      for (const [key, tileData] of Object.entries(this.tiles)) {\n        if (!(key in editorState.tiles)) {\n          removeTile(key);\n          repaintSurroundingWalls(tileData.x, tileData.y);\n        }\n      }\n\n      this.setState((state) => {\n        return {\n          ...state,\n          cursorGridPosition,\n        };\n      });\n\n      this.renderer.render(scene, this.state.camera);\n    };\n\n    animate(this);\n\n    this.mount.addEventListener(\"mousemove\", (e) => {\n      this.mouseX = e.clientX;\n      this.mouseY = e.clientY;\n    });\n\n    this.mount.addEventListener(\"contextmenu\", (e) => {\n      e.preventDefault();\n    });\n\n    this.mount.addEventListener(\"mouseup\", (e) => {\n      const gridX = this.state.cursorGridPosition.x;\n      const gridY = this.state.cursorGridPosition.y;\n\n      e.preventDefault();\n\n      console.log(e.button);\n\n      console.log(\"Adding current tile:\", this.currentSelectedTile);\n\n      if (this.currentSelectedTile.tileId) {\n        if (e.button === 0) {\n          this.editorStateHandler.addTile(\n            gridX,\n            gridY,\n            this.currentSelectedTile\n          );\n          this.recompileState();\n        }\n      }\n\n      if (e.button === 2) {\n        this.editorStateHandler.removeTile(gridX, gridY);\n        this.recompileState();\n      }\n    });\n\n    window.addEventListener( 'resize', this.onCanvasResize, false );\n  }\n\n  render() {\n    return (\n      <>\n        <div className=\"ep-ide-editor\" ref={(ref) => (this.mount = ref)} />\n      </>\n    );\n  }\n}\n\nEnvDesigner.propTypes = {\n  tileset: PropTypes.any,\n  selectedTile: PropTypes.any,\n  onCompile: PropTypes.any,\n  gridHeight: PropTypes.any,\n  gridWidth: PropTypes.any\n};\n\nexport default EnvDesigner;\n"]},"metadata":{},"sourceType":"module"}